/**
 * Integration Test Manager
 * Manages API integration tests for the Junior Football Nutrition Tracker
 */

import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { TestConfig } from './config';
import { testTemplates, renderTemplate } from './test-templates';

export interface APIEndpoint {
  name: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  path: string;
  authentication: boolean;
  parameters: EndpointParameter[];
  requestBody?: any;
  responseSchema: any;
  errorCodes: number[];
  rateLimit?: {
    requests: number;
    windowMs: number;
  };
  ageRestrictions?: string[];
  businessRules: string[];
}

export interface EndpointParameter {
  name: string;
  type: 'query' | 'path' | 'header';
  required: boolean;
  format: string;
  validation?: string;
}

export interface TestScenario {
  name: string;
  description: string;
  endpoint: string;
  method: string;
  auth: boolean;
  data: any;
  expectedStatus: number;
  expectedResponse?: any;
  validations: string[];
  ageGroup?: string;
}

export interface DatabaseOperation {
  table: string;
  operation: 'create' | 'read' | 'update' | 'delete';
  testData: any;
  expectedResult: any;
}

export class IntegrationTestManager {
  constructor(private config: TestConfig) {}

  /**
   * Generate integration tests for all API endpoints
   */
  async generateAllAPITests(): Promise<string[]> {
    const testPaths: string[] = [];
    
    const endpoints = this.getAPIEndpoints();
    
    for (const endpoint of endpoints) {
      const testPath = await this.generateEndpointTests(endpoint);
      testPaths.push(testPath);
    }
    
    return testPaths;
  }

  /**
   * Generate tests for a specific API endpoint
   */
  async generateEndpointTests(endpoint: APIEndpoint): Promise<string> {
    const testScenarios = this.generateEndpointScenarios(endpoint);
    const testCode = this.generateEndpointTestCode(endpoint, testScenarios);
    
    const testFileName = `${endpoint.name.toLowerCase().replace(/\s+/g, '-')}.integration.test.ts`;
    const testPath = join(this.config.paths.tests.integration, testFileName);
    
    await this.ensureDirectory(dirname(testPath));
    await fs.writeFile(testPath, testCode);
    
    return testPath;
  }

  /**
   * Generate authentication flow tests
   */
  async generateAuthIntegrationTests(): Promise<string> {
    const testCode = `/**
 * Authentication Integration Tests
 * Generated by Testing Automation Agent
 */

import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import app from '../../server/src/app';
import { setupTestDb, cleanupTestDb, createTestUser } from '../setup';

describe('Authentication Integration Tests', () => {
  beforeAll(async () => {
    await setupTestDb();
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  beforeEach(async () => {
    // Clean up any existing test users
    await cleanupTestDb();
  });

  describe('User Registration', () => {
    it('should register a new U8 player successfully', async () => {
      const userData = {
        email: 'u8player@fcinter.com',
        password: 'SecurePass123!',
        age: 7,
        parentEmail: 'parent@fcinter.com',
        teamCode: 'FC_INTER_U8'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          email: userData.email,
          age: userData.age,
          ageGroup: 'U8',
          role: 'PLAYER'
        },
        token: expect.any(String)
      });

      // Verify age-specific features are enabled
      expect(response.body.user.features).toEqual(
        expect.arrayContaining(['simple-interface', 'parent-supervision'])
      );
    });

    it('should register a new U15 player successfully', async () => {
      const userData = {
        email: 'u15player@fcinter.com',
        password: 'SecurePass123!',
        age: 14,
        teamCode: 'FC_INTER_U15'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          email: userData.email,
          age: userData.age,
          ageGroup: 'U15',
          role: 'PLAYER'
        },
        token: expect.any(String)
      });

      // Verify advanced features are enabled
      expect(response.body.user.features).toEqual(
        expect.arrayContaining(['advanced-analytics', 'performance-correlation'])
      );
    });

    it('should register a coach successfully', async () => {
      const coachData = {
        email: 'coach@fcinter.com',
        password: 'CoachPass123!',
        role: 'COACH',
        teamCode: 'FC_INTER_U12'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(coachData)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          email: coachData.email,
          role: 'COACH'
        },
        token: expect.any(String)
      });

      expect(response.body.user.permissions).toEqual(
        expect.arrayContaining(['view-team', 'manage-nutrition', 'view-analytics'])
      );
    });

    it('should validate required fields', async () => {
      const incompleteData = {
        email: 'test@fcinter.com'
        // Missing password and age
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(incompleteData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
      expect(response.body.errors).toEqual(
        expect.arrayContaining([
          expect.stringContaining('password'),
          expect.stringContaining('age')
        ])
      );
    });

    it('should prevent duplicate email registration', async () => {
      const userData = {
        email: 'duplicate@fcinter.com',
        password: 'SecurePass123!',
        age: 12
      };

      // First registration should succeed
      await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      // Second registration should fail
      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(409);

      expect(response.body.error).toContain('Email already exists');
    });

    it('should validate email format', async () => {
      const userData = {
        email: 'invalid-email',
        password: 'SecurePass123!',
        age: 12
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([expect.stringContaining('email')])
      );
    });

    it('should validate password strength', async () => {
      const userData = {
        email: 'test@fcinter.com',
        password: '123', // Weak password
        age: 12
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([expect.stringContaining('password')])
      );
    });

    it('should validate age range', async () => {
      const userData = {
        email: 'test@fcinter.com',
        password: 'SecurePass123!',
        age: 25 // Too old for youth program
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([expect.stringContaining('age')])
      );
    });
  });

  describe('User Login', () => {
    let testUser: any;

    beforeEach(async () => {
      testUser = await createTestUser({
        email: 'login@fcinter.com',
        password: 'LoginPass123!',
        age: 12
      });
    });

    it('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'login@fcinter.com',
          password: 'LoginPass123!'
        })
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          id: testUser.id,
          email: testUser.email,
          ageGroup: 'U12'
        },
        token: expect.any(String)
      });

      // Verify token is valid JWT
      expect(response.body.token).toMatch(/^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$/);
    });

    it('should reject invalid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'login@fcinter.com',
          password: 'WrongPassword'
        })
        .expect(401);

      expect(response.body.error).toContain('Invalid credentials');
    });

    it('should reject non-existent user', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'nonexistent@fcinter.com',
          password: 'SomePassword123!'
        })
        .expect(401);

      expect(response.body.error).toContain('Invalid credentials');
    });

    it('should handle rate limiting for failed attempts', async () => {
      const invalidCredentials = {
        email: 'login@fcinter.com',
        password: 'WrongPassword'
      };

      // Make multiple failed attempts
      const attempts = Array(10).fill().map(() =>
        request(app)
          .post('/api/auth/login')
          .send(invalidCredentials)
      );

      const responses = await Promise.allSettled(attempts);
      const rateLimited = responses.filter(
        result => result.status === 'fulfilled' && result.value.status === 429
      );

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  describe('Token Validation', () => {
    let testUser: any;
    let authToken: string;

    beforeEach(async () => {
      testUser = await createTestUser({
        email: 'token@fcinter.com',
        password: 'TokenPass123!',
        age: 12
      });

      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'token@fcinter.com',
          password: 'TokenPass123!'
        });

      authToken = loginResponse.body.token;
    });

    it('should accept valid token for protected routes', async () => {
      const response = await request(app)
        .get('/api/user/profile')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.user.id).toBe(testUser.id);
    });

    it('should reject requests without token', async () => {
      const response = await request(app)
        .get('/api/user/profile')
        .expect(401);

      expect(response.body.error).toContain('Authentication required');
    });

    it('should reject invalid token format', async () => {
      const response = await request(app)
        .get('/api/user/profile')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401);

      expect(response.body.error).toContain('Invalid token');
    });

    it('should reject expired tokens', async () => {
      // This would require mocking the JWT library to create an expired token
      // or waiting for token expiration, which is not practical in tests
      // Instead, we'll test the token validation logic separately
    });
  });

  describe('Password Reset', () => {
    let testUser: any;

    beforeEach(async () => {
      testUser = await createTestUser({
        email: 'reset@fcinter.com',
        password: 'ResetPass123!',
        age: 12
      });
    });

    it('should initiate password reset for valid email', async () => {
      const response = await request(app)
        .post('/api/auth/forgot-password')
        .send({
          email: 'reset@fcinter.com'
        })
        .expect(200);

      expect(response.body.message).toContain('Password reset email sent');
    });

    it('should not reveal non-existent emails', async () => {
      const response = await request(app)
        .post('/api/auth/forgot-password')
        .send({
          email: 'nonexistent@fcinter.com'
        })
        .expect(200);

      // Should return success even for non-existent emails for security
      expect(response.body.message).toContain('Password reset email sent');
    });
  });

  describe('Logout', () => {
    let testUser: any;
    let authToken: string;

    beforeEach(async () => {
      testUser = await createTestUser({
        email: 'logout@fcinter.com',
        password: 'LogoutPass123!',
        age: 12
      });

      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'logout@fcinter.com',
          password: 'LogoutPass123!'
        });

      authToken = loginResponse.body.token;
    });

    it('should logout successfully', async () => {
      const response = await request(app)
        .post('/api/auth/logout')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.message).toContain('Logged out successfully');

      // Verify token is invalidated
      const protectedResponse = await request(app)
        .get('/api/user/profile')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(401);
    });
  });
});`;

    const testPath = join(this.config.paths.tests.integration, 'auth.integration.test.ts');
    await this.ensureDirectory(dirname(testPath));
    await fs.writeFile(testPath, testCode);
    
    return testPath;
  }

  /**
   * Generate food-related API tests
   */
  async generateFoodAPITests(): Promise<string> {
    const testCode = `/**
 * Food API Integration Tests
 * Generated by Testing Automation Agent
 */

import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import app from '../../server/src/app';
import { setupTestDb, cleanupTestDb, createTestUser, getAuthToken } from '../setup';

describe('Food API Integration Tests', () => {
  let authToken: string;
  let testUserId: string;

  beforeAll(async () => {
    await setupTestDb();
    const testUser = await createTestUser({
      email: 'food@fcinter.com',
      password: 'FoodPass123!',
      age: 12,
      role: 'PLAYER'
    });
    testUserId = testUser.id;
    authToken = await getAuthToken(testUser);
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  beforeEach(async () => {
    // Clean up food entries before each test
    await request(app)
      .delete(\`/api/food/entries/user/\${testUserId}\`)
      .set('Authorization', \`Bearer \${authToken}\`);
  });

  describe('Food Entry Creation', () => {
    it('should create food entry with nutrition analysis', async () => {
      const foodEntry = {
        foodName: 'Grilled chicken breast with rice and vegetables',
        mealType: 'LUNCH',
        location: 'Home',
        notes: 'Post-training meal'
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(foodEntry)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        entry: {
          foodName: foodEntry.foodName,
          mealType: foodEntry.mealType,
          location: foodEntry.location,
          notes: foodEntry.notes,
          userId: testUserId,
          nutritionScore: expect.any(Number),
          quality: expect.any(String),
          ageGroup: 'U12'
        },
        analysis: {
          score: expect.any(Number),
          quality: expect.stringMatching(/^(poor|fair|good|excellent)$/),
          nutrients: expect.any(Object),
          recommendations: expect.any(Array),
          ageAdjustments: expect.any(Object)
        }
      });

      expect(response.body.analysis.score).toBeGreaterThan(70); // Should be good quality
      expect(response.body.analysis.quality).toBe('good');
    });

    it('should apply age-specific scoring for U8 players', async () => {
      // Create U8 user
      const u8User = await createTestUser({
        email: 'u8@fcinter.com',
        password: 'U8Pass123!',
        age: 7
      });
      const u8Token = await getAuthToken(u8User);

      const foodEntry = {
        foodName: 'Greek yogurt with berries',
        mealType: 'SNACK'
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${u8Token}\`)
        .send(foodEntry)
        .expect(201);

      expect(response.body.entry.ageGroup).toBe('U8');
      expect(response.body.analysis.ageAdjustments).toMatchObject({
        calorieMultiplier: 0.7,
        proteinMultiplier: 0.8,
        carbMultiplier: 0.9,
        hydrationMultiplier: 1.2
      });

      // Should include age-appropriate recommendations
      expect(response.body.analysis.recommendations).toEqual(
        expect.arrayContaining([expect.stringContaining('hydration')])
      );
    });

    it('should apply age-specific scoring for U15 players', async () => {
      // Create U15 user
      const u15User = await createTestUser({
        email: 'u15@fcinter.com',
        password: 'U15Pass123!',
        age: 14
      });
      const u15Token = await getAuthToken(u15User);

      const foodEntry = {
        foodName: 'Quinoa salad with salmon and avocado',
        mealType: 'LUNCH'
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${u15Token}\`)
        .send(foodEntry)
        .expect(201);

      expect(response.body.entry.ageGroup).toBe('U15');
      expect(response.body.analysis.ageAdjustments).toMatchObject({
        calorieMultiplier: 1.1,
        proteinMultiplier: 1.2,
        carbMultiplier: 1.2,
        hydrationMultiplier: 1.0
      });

      // Should include performance correlation data
      expect(response.body.analysis.performanceImpact).toBeDefined();
      expect(response.body.analysis.energyLevel).toBeDefined();
    });

    it('should validate required fields', async () => {
      const incompleteEntry = {
        mealType: 'LUNCH'
        // Missing foodName
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(incompleteEntry)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([expect.stringContaining('foodName')])
      );
    });

    it('should validate meal type enum', async () => {
      const invalidEntry = {
        foodName: 'Test food',
        mealType: 'INVALID_MEAL_TYPE'
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(invalidEntry)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([expect.stringContaining('mealType')])
      );
    });

    it('should handle meal timing optimization', async () => {
      const preTrainingMeal = {
        foodName: 'Banana with oats',
        mealType: 'SNACK',
        mealTiming: 'PRE_TRAINING'
      };

      const response = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(preTrainingMeal)
        .expect(201);

      expect(response.body.analysis.timingScore).toBeGreaterThan(80);
      expect(response.body.analysis.timingRecommendations).toEqual(
        expect.arrayContaining([expect.stringContaining('energy')])
      );
    });
  });

  describe('Food Quality Analysis', () => {
    const testFoods = ${JSON.stringify(this.config.foodTesting.testFoods, null, 6)};

    Object.entries(testFoods).forEach(([category, foods]) => {
      describe(\`\${category.toUpperCase()} Quality Foods\`, () => {
        foods.forEach(food => {
          it(\`should analyze "\${food.name}" correctly\`, async () => {
            const response = await request(app)
              .post('/api/food/analyze')
              .set('Authorization', \`Bearer \${authToken}\`)
              .send({
                foodName: food.name,
                age: 12
              })
              .expect(200);

            expect(response.body.score).toBeCloseTo(food.expectedScore, 10);
            expect(response.body.quality).toBe(category);
            expect(response.body.detectedKeywords).toEqual(
              expect.arrayContaining(food.keywords)
            );
          });
        });
      });
    });

    it('should provide detailed nutrition breakdown', async () => {
      const response = await request(app)
        .post('/api/food/analyze')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({
          foodName: 'Grilled chicken breast with quinoa and vegetables',
          age: 12
        })
        .expect(200);

      expect(response.body.nutrients).toMatchObject({
        protein: expect.any(Number),
        carbohydrates: expect.any(Number),
        healthyFats: expect.any(Number),
        fiber: expect.any(Number),
        vitamins: expect.any(Array),
        minerals: expect.any(Array)
      });

      expect(response.body.nutrients.protein).toBeGreaterThan(0);
      expect(response.body.nutrients.carbohydrates).toBeGreaterThan(0);
    });

    it('should detect hydration-rich foods', async () => {
      const hydrationFoods = ['Watermelon', 'Cucumber salad', 'Coconut water'];

      for (const food of hydrationFoods) {
        const response = await request(app)
          .post('/api/food/analyze')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({
            foodName: food,
            age: 12
          })
          .expect(200);

        expect(response.body.hydrationScore).toBeGreaterThan(70);
        expect(response.body.detectedKeywords).toEqual(
          expect.arrayContaining(['hydration'])
        );
      }
    });
  });

  describe('Food Entry Retrieval', () => {
    beforeEach(async () => {
      // Create test entries
      const testEntries = [
        { foodName: 'Breakfast oatmeal', mealType: 'BREAKFAST' },
        { foodName: 'Grilled chicken lunch', mealType: 'LUNCH' },
        { foodName: 'Fruit snack', mealType: 'SNACK' }
      ];

      for (const entry of testEntries) {
        await request(app)
          .post('/api/food/entries')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send(entry);
      }
    });

    it('should get all user food entries', async () => {
      const response = await request(app)
        .get('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.entries).toHaveLength(3);
      expect(response.body.entries[0]).toMatchObject({
        foodName: expect.any(String),
        mealType: expect.any(String),
        nutritionScore: expect.any(Number),
        createdAt: expect.any(String)
      });
    });

    it('should filter entries by date range', async () => {
      const today = new Date().toISOString().split('T')[0];
      
      const response = await request(app)
        .get(\`/api/food/entries?startDate=\${today}&endDate=\${today}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.entries.length).toBeGreaterThan(0);
      response.body.entries.forEach(entry => {
        expect(entry.createdAt).toContain(today);
      });
    });

    it('should filter entries by meal type', async () => {
      const response = await request(app)
        .get('/api/food/entries?mealType=LUNCH')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.entries).toHaveLength(1);
      expect(response.body.entries[0].mealType).toBe('LUNCH');
    });

    it('should paginate results', async () => {
      const response = await request(app)
        .get('/api/food/entries?page=1&limit=2')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.entries).toHaveLength(2);
      expect(response.body.pagination).toMatchObject({
        page: 1,
        limit: 2,
        total: 3,
        totalPages: 2
      });
    });
  });

  describe('Food Entry Updates', () => {
    let entryId: string;

    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({
          foodName: 'Original food',
          mealType: 'LUNCH'
        });

      entryId = createResponse.body.entry.id;
    });

    it('should update food entry', async () => {
      const updateData = {
        foodName: 'Updated grilled chicken',
        notes: 'Added notes'
      };

      const response = await request(app)
        .put(\`/api/food/entries/\${entryId}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(updateData)
        .expect(200);

      expect(response.body.entry.foodName).toBe(updateData.foodName);
      expect(response.body.entry.notes).toBe(updateData.notes);
      
      // Should recalculate nutrition score
      expect(response.body.entry.nutritionScore).toBeDefined();
    });

    it('should prevent updating other users entries', async () => {
      const otherUser = await createTestUser({
        email: 'other@fcinter.com',
        password: 'OtherPass123!',
        age: 12
      });
      const otherToken = await getAuthToken(otherUser);

      const response = await request(app)
        .put(\`/api/food/entries/\${entryId}\`)
        .set('Authorization', \`Bearer \${otherToken}\`)
        .send({ foodName: 'Hacked food' })
        .expect(403);

      expect(response.body.error).toContain('Access denied');
    });
  });

  describe('Food Entry Deletion', () => {
    let entryId: string;

    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({
          foodName: 'Food to delete',
          mealType: 'SNACK'
        });

      entryId = createResponse.body.entry.id;
    });

    it('should delete food entry', async () => {
      const response = await request(app)
        .delete(\`/api/food/entries/\${entryId}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.message).toContain('deleted');

      // Verify entry is deleted
      const getResponse = await request(app)
        .get(\`/api/food/entries/\${entryId}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(404);
    });

    it('should prevent deleting other users entries', async () => {
      const otherUser = await createTestUser({
        email: 'other2@fcinter.com',
        password: 'OtherPass123!',
        age: 12
      });
      const otherToken = await getAuthToken(otherUser);

      const response = await request(app)
        .delete(\`/api/food/entries/\${entryId}\`)
        .set('Authorization', \`Bearer \${otherToken}\`)
        .expect(403);

      expect(response.body.error).toContain('Access denied');
    });
  });

  describe('Batch Operations', () => {
    it('should create multiple food entries in batch', async () => {
      const batchData = {
        entries: [
          { foodName: 'Breakfast 1', mealType: 'BREAKFAST' },
          { foodName: 'Lunch 1', mealType: 'LUNCH' },
          { foodName: 'Dinner 1', mealType: 'DINNER' }
        ]
      };

      const response = await request(app)
        .post('/api/food/entries/batch')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(batchData)
        .expect(201);

      expect(response.body.created).toBe(3);
      expect(response.body.entries).toHaveLength(3);
      
      response.body.entries.forEach(entry => {
        expect(entry.nutritionScore).toBeDefined();
        expect(entry.quality).toBeDefined();
      });
    });

    it('should validate all entries in batch', async () => {
      const batchData = {
        entries: [
          { foodName: 'Valid food', mealType: 'BREAKFAST' },
          { mealType: 'LUNCH' }, // Missing foodName
          { foodName: 'Another valid food', mealType: 'INVALID_TYPE' } // Invalid mealType
        ]
      };

      const response = await request(app)
        .post('/api/food/entries/batch')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(batchData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
      expect(response.body.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Performance and Rate Limiting', () => {
    it('should handle concurrent requests', async () => {
      const concurrentRequests = Array(10).fill().map((_, index) =>
        request(app)
          .post('/api/food/entries')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({
            foodName: \`Concurrent food \${index}\`,
            mealType: 'LUNCH'
          })
      );

      const responses = await Promise.all(concurrentRequests);
      
      responses.forEach(response => {
        expect(response.status).toBe(201);
        expect(response.body.entry.nutritionScore).toBeDefined();
      });
    });

    it('should apply rate limiting', async () => {
      const rapidRequests = Array(100).fill().map((_, index) =>
        request(app)
          .post('/api/food/entries')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({
            foodName: \`Rate limit test \${index}\`,
            mealType: 'SNACK'
          })
      );

      const responses = await Promise.allSettled(rapidRequests);
      const rateLimited = responses.filter(
        result => result.status === 'fulfilled' && result.value.status === 429
      );

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });
});`;

    const testPath = join(this.config.paths.tests.integration, 'food-api.integration.test.ts');
    await this.ensureDirectory(dirname(testPath));
    await fs.writeFile(testPath, testCode);
    
    return testPath;
  }

  /**
   * Generate analytics API tests
   */
  async generateAnalyticsAPITests(): Promise<string> {
    const testCode = `/**
 * Analytics API Integration Tests
 * Generated by Testing Automation Agent
 */

import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import app from '../../server/src/app';
import { setupTestDb, cleanupTestDb, createTestUser, getAuthToken } from '../setup';

describe('Analytics API Integration Tests', () => {
  let authToken: string;
  let testUserId: string;

  beforeAll(async () => {
    await setupTestDb();
    const testUser = await createTestUser({
      email: 'analytics@fcinter.com',
      password: 'AnalyticsPass123!',
      age: 12,
      role: 'PLAYER'
    });
    testUserId = testUser.id;
    authToken = await getAuthToken(testUser);
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  beforeEach(async () => {
    // Create test data
    await this.createTestFoodEntries();
  });

  describe('Nutrition Analytics', () => {
    it('should get nutrition overview', async () => {
      const response = await request(app)
        .get('/api/analytics/nutrition')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        overview: {
          averageScore: expect.any(Number),
          totalEntries: expect.any(Number),
          streakDays: expect.any(Number),
          qualityDistribution: {
            excellent: expect.any(Number),
            good: expect.any(Number),
            fair: expect.any(Number),
            poor: expect.any(Number)
          }
        },
        trends: {
          weekly: expect.any(Array),
          monthly: expect.any(Array)
        },
        recommendations: expect.any(Array)
      });
    });

    it('should get age-specific analytics for U12 player', async () => {
      const response = await request(app)
        .get('/api/analytics/nutrition?detailed=true')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.ageSpecific).toMatchObject({
        ageGroup: 'U12',
        adjustments: {
          calorieMultiplier: 0.9,
          proteinMultiplier: 1.0,
          carbMultiplier: 1.1,
          hydrationMultiplier: 1.0
        },
        recommendations: expect.any(Array),
        goals: expect.any(Object)
      });
    });

    it('should filter analytics by date range', async () => {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 7);
      const endDate = new Date();

      const response = await request(app)
        .get(\`/api/analytics/nutrition?startDate=\${startDate.toISOString()}&endDate=\${endDate.toISOString()}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.dateRange).toMatchObject({
        start: expect.any(String),
        end: expect.any(String)
      });

      expect(response.body.overview.totalEntries).toBeGreaterThanOrEqual(0);
    });

    it('should provide meal type breakdown', async () => {
      const response = await request(app)
        .get('/api/analytics/nutrition/breakdown')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.mealTypes).toMatchObject({
        BREAKFAST: expect.any(Number),
        LUNCH: expect.any(Number),
        DINNER: expect.any(Number),
        SNACK: expect.any(Number)
      });

      expect(response.body.averageScoreByMeal).toBeDefined();
    });
  });

  describe('Performance Analytics', () => {
    it('should correlate nutrition with performance', async () => {
      // Create performance data
      await this.createTestPerformanceData();

      const response = await request(app)
        .get('/api/analytics/performance')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        correlations: {
          nutritionVsEnergy: expect.any(Number),
          nutritionVsFocus: expect.any(Number),
          nutritionVsRecovery: expect.any(Number)
        },
        insights: expect.any(Array),
        recommendations: expect.any(Array)
      });
    });

    it('should provide training day analytics', async () => {
      const response = await request(app)
        .get('/api/analytics/performance/training-days')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        preTrainingNutrition: expect.any(Object),
        postTrainingRecovery: expect.any(Object),
        hydrationPatterns: expect.any(Object),
        recommendations: expect.any(Array)
      });
    });

    it('should analyze match day performance', async () => {
      const response = await request(app)
        .get('/api/analytics/performance/match-days')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        preMatchNutrition: expect.any(Object),
        matchDayTiming: expect.any(Object),
        postMatchRecovery: expect.any(Object),
        performanceImpact: expect.any(Object)
      });
    });
  });

  describe('Goal Tracking', () => {
    it('should get goal progress', async () => {
      const response = await request(app)
        .get('/api/analytics/goals')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        currentGoals: expect.any(Array),
        progress: expect.any(Object),
        achievements: expect.any(Array),
        recommendations: expect.any(Array)
      });
    });

    it('should update goal progress', async () => {
      const goalData = {
        type: 'NUTRITION_SCORE',
        target: 80,
        timeframe: 'WEEKLY'
      };

      const response = await request(app)
        .post('/api/analytics/goals')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(goalData)
        .expect(201);

      expect(response.body.goal).toMatchObject({
        type: goalData.type,
        target: goalData.target,
        timeframe: goalData.timeframe,
        userId: testUserId
      });
    });

    it('should track achievement milestones', async () => {
      const response = await request(app)
        .get('/api/analytics/achievements')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        earned: expect.any(Array),
        inProgress: expect.any(Array),
        upcoming: expect.any(Array)
      });

      if (response.body.earned.length > 0) {
        expect(response.body.earned[0]).toMatchObject({
          id: expect.any(String),
          name: expect.any(String),
          description: expect.any(String),
          earnedAt: expect.any(String)
        });
      }
    });
  });

  describe('Team Analytics (Coach Access)', () => {
    let coachToken: string;

    beforeAll(async () => {
      const coach = await createTestUser({
        email: 'coach@fcinter.com',
        password: 'CoachPass123!',
        role: 'COACH'
      });
      coachToken = await getAuthToken(coach);
    });

    it('should get team nutrition overview', async () => {
      const response = await request(app)
        .get('/api/analytics/team/nutrition')
        .set('Authorization', \`Bearer \${coachToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        teamStats: {
          averageScore: expect.any(Number),
          totalPlayers: expect.any(Number),
          activeWeek: expect.any(Number)
        },
        playerRankings: expect.any(Array),
        trends: expect.any(Object)
      });
    });

    it('should prevent player access to team analytics', async () => {
      const response = await request(app)
        .get('/api/analytics/team/nutrition')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(403);

      expect(response.body.error).toContain('Access denied');
    });

    it('should get individual player analytics for coach', async () => {
      const response = await request(app)
        .get(\`/api/analytics/player/\${testUserId}\`)
        .set('Authorization', \`Bearer \${coachToken}\`)
        .expect(200);

      expect(response.body).toMatchObject({
        player: {
          id: testUserId,
          ageGroup: 'U12'
        },
        nutrition: expect.any(Object),
        performance: expect.any(Object),
        goals: expect.any(Array)
      });
    });
  });

  describe('Export and Reporting', () => {
    it('should export nutrition data as CSV', async () => {
      const response = await request(app)
        .get('/api/analytics/export/nutrition?format=csv')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.headers['content-type']).toContain('text/csv');
      expect(response.headers['content-disposition']).toContain('attachment');
      expect(response.text).toContain('Date,Food Name,Meal Type,Score,Quality');
    });

    it('should export analytics as JSON', async () => {
      const response = await request(app)
        .get('/api/analytics/export/nutrition?format=json')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.headers['content-type']).toContain('application/json');
      expect(response.body.data).toBeDefined();
      expect(response.body.metadata).toBeDefined();
    });

    it('should generate PDF report', async () => {
      const response = await request(app)
        .get('/api/analytics/report/weekly?format=pdf')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.headers['content-type']).toContain('application/pdf');
      expect(response.headers['content-disposition']).toContain('attachment');
    });
  });

  // Helper methods
  private async createTestFoodEntries() {
    const testEntries = [
      { foodName: 'Grilled chicken with rice', mealType: 'LUNCH', score: 80 },
      { foodName: 'Greek yogurt with berries', mealType: 'SNACK', score: 85 },
      { foodName: 'Oatmeal with fruit', mealType: 'BREAKFAST', score: 75 },
      { foodName: 'Salmon with quinoa', mealType: 'DINNER', score: 90 },
      { foodName: 'Candy bar', mealType: 'SNACK', score: 25 }
    ];

    for (const entry of testEntries) {
      await request(app)
        .post('/api/food/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(entry);
    }
  }

  private async createTestPerformanceData() {
    const performanceData = [
      { date: new Date(), energy: 8, focus: 7, recovery: 8 },
      { date: new Date(Date.now() - 86400000), energy: 6, focus: 6, recovery: 7 },
      { date: new Date(Date.now() - 172800000), energy: 9, focus: 8, recovery: 9 }
    ];

    for (const data of performanceData) {
      await request(app)
        .post('/api/performance/entries')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(data);
    }
  }
});`;

    const testPath = join(this.config.paths.tests.integration, 'analytics-api.integration.test.ts');
    await this.ensureDirectory(dirname(testPath));
    await fs.writeFile(testPath, testCode);
    
    return testPath;
  }

  /**
   * Generate database integration tests
   */
  async generateDatabaseTests(): Promise<string> {
    const testCode = `/**
 * Database Integration Tests
 * Generated by Testing Automation Agent
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { setupTestDb, cleanupTestDb, createTestUser } from '../setup';

describe('Database Integration Tests', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    await setupTestDb();
    prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.TEST_DATABASE_URL
        }
      }
    });
  });

  afterAll(async () => {
    await cleanupTestDb();
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    // Clean up data before each test
    await prisma.foodEntry.deleteMany();
    await prisma.user.deleteMany();
  });

  describe('User Operations', () => {
    it('should create user with age-specific data', async () => {
      const userData = {
        email: 'db-test@fcinter.com',
        password: 'DbTest123!',
        age: 12,
        ageGroup: 'U12',
        role: 'PLAYER'
      };

      const user = await prisma.user.create({
        data: userData
      });

      expect(user).toMatchObject({
        id: expect.any(String),
        email: userData.email,
        age: userData.age,
        ageGroup: userData.ageGroup,
        role: userData.role,
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date)
      });

      // Verify user can be retrieved
      const retrievedUser = await prisma.user.findUnique({
        where: { id: user.id }
      });

      expect(retrievedUser).toMatchObject(userData);
    });

    it('should enforce unique email constraint', async () => {
      const userData = {
        email: 'duplicate@fcinter.com',
        password: 'Test123!',
        age: 12,
        ageGroup: 'U12'
      };

      await prisma.user.create({ data: userData });

      await expect(prisma.user.create({ data: userData })).rejects.toThrow();
    });

    it('should cascade delete user data', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'cascade@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });

      // Create food entries for user
      await prisma.foodEntry.createMany({
        data: [
          {
            userId: user.id,
            foodName: 'Test Food 1',
            mealType: 'LUNCH',
            nutritionScore: 80,
            quality: 'good'
          },
          {
            userId: user.id,
            foodName: 'Test Food 2',
            mealType: 'DINNER',
            nutritionScore: 90,
            quality: 'excellent'
          }
        ]
      });

      // Verify food entries exist
      const entriesBeforeDelete = await prisma.foodEntry.count({
        where: { userId: user.id }
      });
      expect(entriesBeforeDelete).toBe(2);

      // Delete user
      await prisma.user.delete({
        where: { id: user.id }
      });

      // Verify food entries are deleted (cascade)
      const entriesAfterDelete = await prisma.foodEntry.count({
        where: { userId: user.id }
      });
      expect(entriesAfterDelete).toBe(0);
    });
  });

  describe('Food Entry Operations', () => {
    let testUser: any;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'food-test@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });
    });

    it('should create food entry with nutrition data', async () => {
      const entryData = {
        userId: testUser.id,
        foodName: 'Grilled chicken breast',
        mealType: 'LUNCH',
        location: 'Home',
        notes: 'Post-training meal',
        nutritionScore: 85,
        quality: 'good',
        nutrients: {
          protein: 30,
          carbs: 20,
          fats: 5
        },
        ageGroup: 'U12'
      };

      const entry = await prisma.foodEntry.create({
        data: entryData
      });

      expect(entry).toMatchObject({
        id: expect.any(String),
        userId: testUser.id,
        foodName: entryData.foodName,
        mealType: entryData.mealType,
        nutritionScore: entryData.nutritionScore,
        quality: entryData.quality,
        createdAt: expect.any(Date)
      });
    });

    it('should query entries by date range', async () => {
      const today = new Date();
      const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
      const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);

      // Create entries for different dates
      await prisma.foodEntry.createMany({
        data: [
          {
            userId: testUser.id,
            foodName: 'Yesterday food',
            mealType: 'LUNCH',
            nutritionScore: 70,
            quality: 'good',
            createdAt: yesterday
          },
          {
            userId: testUser.id,
            foodName: 'Today food',
            mealType: 'LUNCH',
            nutritionScore: 80,
            quality: 'good',
            createdAt: today
          }
        ]
      });

      // Query for today's entries
      const todayEntries = await prisma.foodEntry.findMany({
        where: {
          userId: testUser.id,
          createdAt: {
            gte: new Date(today.setHours(0, 0, 0, 0)),
            lt: new Date(today.setHours(23, 59, 59, 999))
          }
        }
      });

      expect(todayEntries).toHaveLength(1);
      expect(todayEntries[0].foodName).toBe('Today food');
    });

    it('should aggregate nutrition scores', async () => {
      // Create multiple entries
      await prisma.foodEntry.createMany({
        data: [
          { userId: testUser.id, foodName: 'Food 1', mealType: 'BREAKFAST', nutritionScore: 80, quality: 'good' },
          { userId: testUser.id, foodName: 'Food 2', mealType: 'LUNCH', nutritionScore: 90, quality: 'excellent' },
          { userId: testUser.id, foodName: 'Food 3', mealType: 'DINNER', nutritionScore: 70, quality: 'good' },
          { userId: testUser.id, foodName: 'Food 4', mealType: 'SNACK', nutritionScore: 60, quality: 'fair' }
        ]
      });

      // Get aggregated stats
      const stats = await prisma.foodEntry.aggregate({
        where: { userId: testUser.id },
        _avg: { nutritionScore: true },
        _min: { nutritionScore: true },
        _max: { nutritionScore: true },
        _count: { id: true }
      });

      expect(stats._avg.nutritionScore).toBeCloseTo(75, 1);
      expect(stats._min.nutritionScore).toBe(60);
      expect(stats._max.nutritionScore).toBe(90);
      expect(stats._count.id).toBe(4);
    });

    it('should group entries by meal type', async () => {
      // Create entries for different meal types
      await prisma.foodEntry.createMany({
        data: [
          { userId: testUser.id, foodName: 'Breakfast 1', mealType: 'BREAKFAST', nutritionScore: 80, quality: 'good' },
          { userId: testUser.id, foodName: 'Breakfast 2', mealType: 'BREAKFAST', nutritionScore: 85, quality: 'good' },
          { userId: testUser.id, foodName: 'Lunch 1', mealType: 'LUNCH', nutritionScore: 90, quality: 'excellent' },
          { userId: testUser.id, foodName: 'Snack 1', mealType: 'SNACK', nutritionScore: 70, quality: 'good' }
        ]
      });

      // Group by meal type
      const groupedEntries = await prisma.foodEntry.groupBy({
        by: ['mealType'],
        where: { userId: testUser.id },
        _avg: { nutritionScore: true },
        _count: { id: true }
      });

      expect(groupedEntries).toHaveLength(3); // BREAKFAST, LUNCH, SNACK
      
      const breakfastGroup = groupedEntries.find(g => g.mealType === 'BREAKFAST');
      expect(breakfastGroup._count.id).toBe(2);
      expect(breakfastGroup._avg.nutritionScore).toBeCloseTo(82.5, 1);
    });
  });

  describe('Performance Operations', () => {
    let testUser: any;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'perf-test@fcinter.com',
          password: 'Test123!',
          age: 14,
          ageGroup: 'U15'
        }
      });
    });

    it('should track performance metrics', async () => {
      const performanceData = {
        userId: testUser.id,
        date: new Date(),
        energyLevel: 8,
        focusLevel: 7,
        recoveryRate: 9,
        overallRating: 8
      };

      const performance = await prisma.performanceEntry.create({
        data: performanceData
      });

      expect(performance).toMatchObject({
        id: expect.any(String),
        userId: testUser.id,
        energyLevel: performanceData.energyLevel,
        focusLevel: performanceData.focusLevel,
        recoveryRate: performanceData.recoveryRate,
        overallRating: performanceData.overallRating
      });
    });

    it('should correlate nutrition with performance', async () => {
      const date = new Date();
      
      // Create food entry
      await prisma.foodEntry.create({
        data: {
          userId: testUser.id,
          foodName: 'High quality meal',
          mealType: 'LUNCH',
          nutritionScore: 90,
          quality: 'excellent',
          createdAt: date
        }
      });

      // Create performance entry for same day
      await prisma.performanceEntry.create({
        data: {
          userId: testUser.id,
          date: date,
          energyLevel: 9,
          focusLevel: 8,
          recoveryRate: 9,
          overallRating: 9
        }
      });

      // Query correlated data
      const correlatedData = await prisma.user.findUnique({
        where: { id: testUser.id },
        include: {
          foodEntries: {
            where: {
              createdAt: {
                gte: new Date(date.setHours(0, 0, 0, 0)),
                lt: new Date(date.setHours(23, 59, 59, 999))
              }
            }
          },
          performanceEntries: {
            where: {
              date: {
                gte: new Date(date.setHours(0, 0, 0, 0)),
                lt: new Date(date.setHours(23, 59, 59, 999))
              }
            }
          }
        }
      });

      expect(correlatedData.foodEntries).toHaveLength(1);
      expect(correlatedData.performanceEntries).toHaveLength(1);
      expect(correlatedData.foodEntries[0].nutritionScore).toBe(90);
      expect(correlatedData.performanceEntries[0].overallRating).toBe(9);
    });
  });

  describe('Data Integrity and Constraints', () => {
    it('should enforce age group constraints', async () => {
      const invalidAgeGroupData = {
        email: 'invalid-age@fcinter.com',
        password: 'Test123!',
        age: 12,
        ageGroup: 'INVALID_GROUP' // Invalid age group
      };

      await expect(prisma.user.create({ data: invalidAgeGroupData })).rejects.toThrow();
    });

    it('should enforce meal type constraints', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'meal-test@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });

      const invalidMealTypeData = {
        userId: user.id,
        foodName: 'Test food',
        mealType: 'INVALID_MEAL', // Invalid meal type
        nutritionScore: 80,
        quality: 'good'
      };

      await expect(prisma.foodEntry.create({ data: invalidMealTypeData })).rejects.toThrow();
    });

    it('should enforce nutrition score ranges', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'score-test@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });

      // Test with invalid score (> 100)
      const invalidScoreData = {
        userId: user.id,
        foodName: 'Test food',
        mealType: 'LUNCH',
        nutritionScore: 150, // Invalid score
        quality: 'good'
      };

      await expect(prisma.foodEntry.create({ data: invalidScoreData })).rejects.toThrow();
    });
  });

  describe('Transaction Handling', () => {
    it('should handle transactional operations', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'transaction@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });

      // Simulate batch food entry creation in transaction
      const result = await prisma.$transaction(async (tx) => {
        const entry1 = await tx.foodEntry.create({
          data: {
            userId: user.id,
            foodName: 'Transaction Food 1',
            mealType: 'BREAKFAST',
            nutritionScore: 80,
            quality: 'good'
          }
        });

        const entry2 = await tx.foodEntry.create({
          data: {
            userId: user.id,
            foodName: 'Transaction Food 2',
            mealType: 'LUNCH',
            nutritionScore: 85,
            quality: 'good'
          }
        });

        return { entry1, entry2 };
      });

      expect(result.entry1.foodName).toBe('Transaction Food 1');
      expect(result.entry2.foodName).toBe('Transaction Food 2');

      // Verify both entries were created
      const entries = await prisma.foodEntry.findMany({
        where: { userId: user.id }
      });
      expect(entries).toHaveLength(2);
    });

    it('should rollback failed transactions', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'rollback@fcinter.com',
          password: 'Test123!',
          age: 12,
          ageGroup: 'U12'
        }
      });

      // Transaction that should fail
      await expect(
        prisma.$transaction(async (tx) => {
          await tx.foodEntry.create({
            data: {
              userId: user.id,
              foodName: 'Valid Food',
              mealType: 'BREAKFAST',
              nutritionScore: 80,
              quality: 'good'
            }
          });

          // This should fail and rollback the entire transaction
          await tx.foodEntry.create({
            data: {
              userId: user.id,
              foodName: 'Invalid Food',
              mealType: 'INVALID_TYPE', // Invalid meal type
              nutritionScore: 80,
              quality: 'good'
            }
          });
        })
      ).rejects.toThrow();

      // Verify no entries were created (rollback worked)
      const entries = await prisma.foodEntry.findMany({
        where: { userId: user.id }
      });
      expect(entries).toHaveLength(0);
    });
  });
});`;

    const testPath = join(this.config.paths.tests.integration, 'database.integration.test.ts');
    await this.ensureDirectory(dirname(testPath));
    await fs.writeFile(testPath, testCode);
    
    return testPath;
  }

  /**
   * Get API endpoints configuration
   */
  private getAPIEndpoints(): APIEndpoint[] {
    return [
      {
        name: 'User Registration',
        method: 'POST',
        path: '/api/auth/register',
        authentication: false,
        parameters: [],
        requestBody: {
          email: 'string',
          password: 'string',
          age: 'number',
          teamCode: 'string?'
        },
        responseSchema: {
          success: 'boolean',
          user: 'User',
          token: 'string'
        },
        errorCodes: [400, 409],
        businessRules: ['Email must be unique', 'Age must be between 6-15'],
        ageRestrictions: ['U8 requires parent email']
      },
      {
        name: 'User Login',
        method: 'POST',
        path: '/api/auth/login',
        authentication: false,
        parameters: [],
        requestBody: {
          email: 'string',
          password: 'string'
        },
        responseSchema: {
          success: 'boolean',
          user: 'User',
          token: 'string'
        },
        errorCodes: [401, 429],
        rateLimit: { requests: 5, windowMs: 900000 }, // 5 attempts per 15 minutes
        businessRules: ['Account lockout after 5 failed attempts']
      },
      {
        name: 'Create Food Entry',
        method: 'POST',
        path: '/api/food/entries',
        authentication: true,
        parameters: [],
        requestBody: {
          foodName: 'string',
          mealType: 'enum',
          location: 'string?',
          notes: 'string?',
          mealTiming: 'enum?'
        },
        responseSchema: {
          success: 'boolean',
          entry: 'FoodEntry',
          analysis: 'NutritionAnalysis'
        },
        errorCodes: [400, 401, 429],
        businessRules: ['Food name required', 'Valid meal type required'],
        ageRestrictions: ['U8: simplified interface', 'U15: advanced features']
      },
      {
        name: 'Food Analysis',
        method: 'POST',
        path: '/api/food/analyze',
        authentication: true,
        parameters: [],
        requestBody: {
          foodName: 'string',
          age: 'number',
          mealTiming: 'enum?'
        },
        responseSchema: {
          score: 'number',
          quality: 'string',
          nutrients: 'object',
          recommendations: 'array'
        },
        errorCodes: [400, 401],
        businessRules: ['Age-specific scoring applied', 'Real-time analysis']
      },
      {
        name: 'Get Analytics',
        method: 'GET',
        path: '/api/analytics/nutrition',
        authentication: true,
        parameters: [
          { name: 'startDate', type: 'query', required: false, format: 'date' },
          { name: 'endDate', type: 'query', required: false, format: 'date' },
          { name: 'detailed', type: 'query', required: false, format: 'boolean' }
        ],
        responseSchema: {
          overview: 'object',
          trends: 'object',
          recommendations: 'array'
        },
        errorCodes: [401, 404],
        businessRules: ['User can only see own analytics', 'Coaches can see team analytics']
      }
    ];
  }

  /**
   * Generate test scenarios for an endpoint
   */
  private generateEndpointScenarios(endpoint: APIEndpoint): TestScenario[] {
    const scenarios: TestScenario[] = [];
    
    // Happy path scenario
    scenarios.push({
      name: `${endpoint.name} - Success`,
      description: `Test successful ${endpoint.name.toLowerCase()}`,
      endpoint: endpoint.path,
      method: endpoint.method,
      auth: endpoint.authentication,
      data: this.generateValidTestData(endpoint),
      expectedStatus: endpoint.method === 'POST' ? 201 : 200,
      validations: ['Response should match schema', 'Data should be persisted']
    });
    
    // Authentication test
    if (endpoint.authentication) {
      scenarios.push({
        name: `${endpoint.name} - No Auth`,
        description: `Test ${endpoint.name.toLowerCase()} without authentication`,
        endpoint: endpoint.path,
        method: endpoint.method,
        auth: false,
        data: this.generateValidTestData(endpoint),
        expectedStatus: 401,
        validations: ['Should return authentication error']
      });
    }
    
    // Validation errors
    scenarios.push({
      name: `${endpoint.name} - Invalid Data`,
      description: `Test ${endpoint.name.toLowerCase()} with invalid data`,
      endpoint: endpoint.path,
      method: endpoint.method,
      auth: endpoint.authentication,
      data: this.generateInvalidTestData(endpoint),
      expectedStatus: 400,
      validations: ['Should return validation errors']
    });
    
    // Age-specific scenarios
    if (endpoint.ageRestrictions) {
      Object.keys(this.config.ageGroups).forEach(ageGroup => {
        scenarios.push({
          name: `${endpoint.name} - ${ageGroup}`,
          description: `Test ${endpoint.name.toLowerCase()} for ${ageGroup} players`,
          endpoint: endpoint.path,
          method: endpoint.method,
          auth: endpoint.authentication,
          data: this.generateAgeSpecificTestData(endpoint, ageGroup),
          expectedStatus: endpoint.method === 'POST' ? 201 : 200,
          validations: [`Should apply ${ageGroup} specific rules`],
          ageGroup
        });
      });
    }
    
    return scenarios;
  }

  private generateValidTestData(endpoint: APIEndpoint): any {
    switch (endpoint.name) {
      case 'User Registration':
        return {
          email: 'test@fcinter.com',
          password: 'SecurePass123!',
          age: 12,
          teamCode: 'FC_INTER_U12'
        };
      case 'User Login':
        return {
          email: 'test@fcinter.com',
          password: 'SecurePass123!'
        };
      case 'Create Food Entry':
        return {
          foodName: 'Grilled chicken with rice',
          mealType: 'LUNCH',
          location: 'Home',
          notes: 'Post-training meal'
        };
      case 'Food Analysis':
        return {
          foodName: 'Greek yogurt with berries',
          age: 12,
          mealTiming: 'POST_TRAINING'
        };
      default:
        return {};
    }
  }

  private generateInvalidTestData(endpoint: APIEndpoint): any {
    switch (endpoint.name) {
      case 'User Registration':
        return {
          email: 'invalid-email',
          password: '123', // Too short
          age: 25 // Too old
        };
      case 'User Login':
        return {
          email: 'invalid-email',
          // Missing password
        };
      case 'Create Food Entry':
        return {
          // Missing foodName
          mealType: 'INVALID_MEAL_TYPE'
        };
      case 'Food Analysis':
        return {
          // Missing foodName
          age: -1 // Invalid age
        };
      default:
        return {};
    }
  }

  private generateAgeSpecificTestData(endpoint: APIEndpoint, ageGroup: string): any {
    const ageConfig = this.config.ageGroups[ageGroup];
    const testAge = Math.floor((ageConfig.minAge + ageConfig.maxAge) / 2);
    
    const baseData = this.generateValidTestData(endpoint);
    
    if ('age' in baseData) {
      baseData.age = testAge;
    }
    
    return baseData;
  }

  /**
   * Generate test code for an endpoint
   */
  private generateEndpointTestCode(endpoint: APIEndpoint, scenarios: TestScenario[]): string {
    const variables = {
      API_NAME: endpoint.name,
      API_ENDPOINT: endpoint.path,
      HTTP_METHOD: endpoint.method.toLowerCase(),
      SUCCESS_STATUS: endpoint.method === 'POST' ? '201' : '200',
      APP_PATH: '../../server/src/app',
      TEST_DATA: JSON.stringify(this.generateValidTestData(endpoint), null, 2),
      EXPECTED_RESPONSE_STRUCTURE: this.generateResponseStructure(endpoint),
      REQUIRED_FIELD: Object.keys(endpoint.requestBody || {})[0] || 'field',
      INVALID_DATA_TYPES: JSON.stringify(this.generateInvalidTestData(endpoint), null, 2),
      BUSINESS_RULE_VIOLATION_DATA: JSON.stringify(this.generateBusinessRuleViolationData(endpoint), null, 2),
      BUSINESS_RULE_ERROR: this.generateBusinessRuleError(endpoint),
      REQUEST_BODY: endpoint.method !== 'GET' ? '.send(testData)' : ''
    };
    
    const template = testTemplates.apiIntegration.template;
    return renderTemplate(template, variables);
  }

  private generateResponseStructure(endpoint: APIEndpoint): string {
    return Object.entries(endpoint.responseSchema)
      .map(([key, type]) => `${key}: expect.any(${this.mapTypeToExpect(type)})`)
      .join(',\n        ');
  }

  private mapTypeToExpect(type: string): string {
    switch (type) {
      case 'string': return 'String';
      case 'number': return 'Number';
      case 'boolean': return 'Boolean';
      case 'array': return 'Array';
      case 'object': return 'Object';
      default: return 'Object';
    }
  }

  private generateBusinessRuleViolationData(endpoint: APIEndpoint): any {
    switch (endpoint.name) {
      case 'User Registration':
        return {
          email: 'duplicate@fcinter.com', // Assuming this email exists
          password: 'SecurePass123!',
          age: 12
        };
      case 'Create Food Entry':
        return {
          foodName: '', // Empty food name
          mealType: 'LUNCH'
        };
      default:
        return {};
    }
  }

  private generateBusinessRuleError(endpoint: APIEndpoint): string {
    switch (endpoint.name) {
      case 'User Registration':
        return 'Email already exists';
      case 'Create Food Entry':
        return 'Food name cannot be empty';
      default:
        return 'Business rule violation';
    }
  }

  private async ensureDirectory(dir: string): Promise<void> {
    try {
      await fs.mkdir(dir, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }
  }

  /**
   * Generate all integration tests
   */
  async generateAllIntegrationTests(): Promise<{
    endpoints: string[];
    auth: string;
    food: string;
    analytics: string;
    database: string;
  }> {
    const results = {
      endpoints: await this.generateAllAPITests(),
      auth: await this.generateAuthIntegrationTests(),
      food: await this.generateFoodAPITests(),
      analytics: await this.generateAnalyticsAPITests(),
      database: await this.generateDatabaseTests()
    };

    console.log('✅ Generated all integration tests successfully!');
    console.log('Generated test files:', [
      ...results.endpoints,
      results.auth,
      results.food,
      results.analytics,
      results.database
    ]);

    return results;
  }
}