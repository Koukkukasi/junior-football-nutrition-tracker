/**
 * Test Templates for the Testing Automation Agent
 * Templates for different test types including E2E, unit, integration, and nutrition-specific tests
 */

import { TestConfig } from './config';

export interface TestTemplate {
  name: string;
  type: 'e2e' | 'unit' | 'integration' | 'component';
  description: string;
  template: string;
  dependencies: string[];
  setup?: string;
  teardown?: string;
}

/**
 * Component Test Template
 */
export const componentTestTemplate: TestTemplate = {
  name: 'component-test',
  type: 'component',
  description: 'Template for React component tests',
  dependencies: ['@testing-library/react', '@testing-library/jest-dom', '@testing-library/user-event'],
  template: `/**
 * {{COMPONENT_NAME}} Component Tests
 * Generated by Testing Automation Agent
 */

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';
import { {{COMPONENT_NAME}} } from '{{COMPONENT_PATH}}';
{{IMPORTS}}

// Mock dependencies
{{MOCKS}}

describe('{{COMPONENT_NAME}}', () => {
  const defaultProps = {
    {{DEFAULT_PROPS}}
  };

  beforeEach(() => {
    vi.clearAllMocks();
    {{BEFORE_EACH_SETUP}}
  });

  afterEach(() => {
    {{AFTER_EACH_CLEANUP}}
  });

  describe('Rendering', () => {
    it('should render without crashing', () => {
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      expect(screen.getByRole('{{MAIN_ROLE}}')).toBeInTheDocument();
    });

    it('should display required elements', () => {
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{REQUIRED_ELEMENTS_TESTS}}
    });

    it('should apply correct CSS classes', () => {
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      const element = screen.getByRole('{{MAIN_ROLE}}');
      
      {{CSS_CLASS_TESTS}}
    });
  });

  describe('Interactions', () => {
    it('should handle user interactions correctly', async () => {
      const user = userEvent.setup();
      const mockHandler = vi.fn();
      
      render(<{{COMPONENT_NAME}} {...defaultProps} {{INTERACTION_PROPS}}={mockHandler} />);
      
      {{INTERACTION_TESTS}}
    });

    it('should validate form inputs', async () => {
      const user = userEvent.setup();
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{VALIDATION_TESTS}}
    });
  });

  describe('Props', () => {
    it('should handle prop changes', () => {
      const { rerender } = render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{PROP_CHANGE_TESTS}}
    });

    it('should handle missing optional props', () => {
      const minimalProps = {
        {{MINIMAL_PROPS}}
      };
      
      expect(() => render(<{{COMPONENT_NAME}} {...minimalProps} />)).not.toThrow();
    });
  });

  describe('Accessibility', () => {
    it('should have correct ARIA attributes', () => {
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{ARIA_TESTS}}
    });

    it('should be keyboard navigable', async () => {
      const user = userEvent.setup();
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{KEYBOARD_TESTS}}
    });

    it('should have proper focus management', () => {
      render(<{{COMPONENT_NAME}} {...defaultProps} />);
      
      {{FOCUS_TESTS}}
    });
  });

  describe('Error Handling', () => {
    it('should handle errors gracefully', () => {
      const consoleError = vi.spyOn(console, 'error').mockImplementation(() => {});
      
      {{ERROR_HANDLING_TESTS}}
      
      consoleError.mockRestore();
    });
  });

  {{ADDITIONAL_TESTS}}
});`
};

/**
 * Food Analysis Function Test Template
 */
export const foodAnalysisTestTemplate: TestTemplate = {
  name: 'food-analysis-test',
  type: 'unit',
  description: 'Template for testing food analysis and scoring functions',
  dependencies: ['vitest'],
  template: `/**
 * Food Analysis Tests - {{FUNCTION_NAME}}
 * Generated by Testing Automation Agent
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { {{FUNCTION_NAME}} } from '{{FUNCTION_PATH}}';
{{ADDITIONAL_IMPORTS}}

describe('{{FUNCTION_NAME}}', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Food Quality Scoring', () => {
    it('should score excellent foods correctly', () => {
      const excellentFoods = [
        'Quinoa salad with salmon and vegetables',
        'Greek yogurt with berries and nuts',
        'Grilled chicken breast with sweet potato',
        'Oatmeal with fruit and almonds'
      ];

      excellentFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.score).toBeGreaterThan(85);
        expect(result.quality).toBe('excellent');
      });
    });

    it('should score good foods correctly', () => {
      const goodFoods = [
        'Grilled chicken with rice',
        'Pasta with vegetables',
        'Tuna sandwich on whole grain',
        'Fruit smoothie with protein'
      ];

      goodFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.score).toBeGreaterThan(65);
        expect(result.score).toBeLessThan(85);
        expect(result.quality).toBe('good');
      });
    });

    it('should score fair foods correctly', () => {
      const fairFoods = [
        'White bread sandwich',
        'Cereal with milk',
        'Pasta with butter',
        'Rice with vegetables'
      ];

      fairFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.score).toBeGreaterThan(40);
        expect(result.score).toBeLessThan(65);
        expect(result.quality).toBe('fair');
      });
    });

    it('should score poor foods correctly', () => {
      const poorFoods = [
        'Candy bar with chips',
        'Energy drink',
        'Fast food burger and fries',
        'Sugary cereal'
      ];

      poorFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.score).toBeLessThan(40);
        expect(result.quality).toBe('poor');
      });
    });
  });

  describe('Age-Specific Scoring', () => {
    const testFood = 'Grilled chicken with vegetables';

    it('should apply U8 age multipliers correctly', () => {
      const result = {{FUNCTION_NAME}}(testFood, 7);
      expect(result.ageAdjustments).toBeDefined();
      expect(result.ageAdjustments.hydrationBonus).toBeGreaterThan(1);
    });

    it('should apply U10 age multipliers correctly', () => {
      const result = {{FUNCTION_NAME}}(testFood, 9);
      expect(result.ageAdjustments).toBeDefined();
      expect(result.ageAdjustments.proteinBonus).toBeGreaterThan(0);
    });

    it('should apply U12 age multipliers correctly', () => {
      const result = {{FUNCTION_NAME}}(testFood, 11);
      expect(result.ageAdjustments).toBeDefined();
      expect(result.recommendations).toContain('team nutrition');
    });

    it('should apply U15 age multipliers correctly', () => {
      const result = {{FUNCTION_NAME}}(testFood, 14);
      expect(result.ageAdjustments).toBeDefined();
      expect(result.ageAdjustments.calorieMultiplier).toBeGreaterThan(1);
    });
  });

  describe('Meal Timing Analysis', () => {
    it('should provide pre-training recommendations', () => {
      const result = {{FUNCTION_NAME}}('Banana with oats', {{AGE_PARAM}}, 'PRE_TRAINING');
      expect(result.timingScore).toBeGreaterThan(80);
      expect(result.recommendations).toContain('carbohydrate');
    });

    it('should provide post-training recommendations', () => {
      const result = {{FUNCTION_NAME}}('Chocolate milk with protein', {{AGE_PARAM}}, 'POST_TRAINING');
      expect(result.timingScore).toBeGreaterThan(85);
      expect(result.recommendations).toContain('recovery');
    });

    it('should provide match day recommendations', () => {
      const result = {{FUNCTION_NAME}}('Pasta with lean protein', {{AGE_PARAM}}, 'MATCH_DAY');
      expect(result.timingScore).toBeGreaterThan(75);
      expect(result.recommendations).toContain('sustained energy');
    });
  });

  describe('Hydration Analysis', () => {
    it('should detect hydration-rich foods', () => {
      const hydrationFoods = ['Watermelon', 'Cucumber salad', 'Sports drink', 'Coconut water'];
      
      hydrationFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.hydrationScore).toBeGreaterThan(70);
      });
    });

    it('should provide hydration warnings for dehydrating foods', () => {
      const dehydratingFoods = ['Coffee', 'Energy drink with caffeine', 'Salty snacks'];
      
      dehydratingFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.warnings).toContain('hydration');
      });
    });
  });

  describe('Nutritional Keywords Detection', () => {
    it('should detect protein keywords', () => {
      const proteinFoods = ['Chicken breast', 'Greek yogurt', 'Quinoa', 'Lean beef'];
      
      proteinFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.nutrients.protein).toBeGreaterThan(0);
        expect(result.detectedKeywords).toContain('protein');
      });
    });

    it('should detect complex carbohydrate keywords', () => {
      const carbFoods = ['Brown rice', 'Oatmeal', 'Sweet potato', 'Quinoa'];
      
      carbFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.nutrients.carbohydrates).toBeGreaterThan(0);
        expect(result.detectedKeywords).toContain('complex carbs');
      });
    });

    it('should detect healthy fat keywords', () => {
      const fatFoods = ['Avocado', 'Nuts', 'Olive oil', 'Salmon'];
      
      fatFoods.forEach(food => {
        const result = {{FUNCTION_NAME}}(food, {{AGE_PARAM}});
        expect(result.nutrients.healthyFats).toBeGreaterThan(0);
        expect(result.detectedKeywords).toContain('healthy fats');
      });
    });
  });

  describe('Performance Correlation', () => {
    it('should provide performance insights for excellent foods', () => {
      const result = {{FUNCTION_NAME}}('Quinoa salad with salmon', {{AGE_PARAM}});
      expect(result.performanceImpact).toBe('positive');
      expect(result.energyLevel).toBe('sustained');
    });

    it('should warn about poor foods impact on performance', () => {
      const result = {{FUNCTION_NAME}}('Candy and chips', {{AGE_PARAM}});
      expect(result.performanceImpact).toBe('negative');
      expect(result.warnings).toContain('performance');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty food names', () => {
      expect(() => {{FUNCTION_NAME}}('', {{AGE_PARAM}})).not.toThrow();
      const result = {{FUNCTION_NAME}}('', {{AGE_PARAM}});
      expect(result.score).toBe(0);
    });

    it('should handle invalid age values', () => {
      expect(() => {{FUNCTION_NAME}}('Test food', -1)).not.toThrow();
      expect(() => {{FUNCTION_NAME}}('Test food', 150)).not.toThrow();
    });

    it('should handle very long food names', () => {
      const longName = 'A'.repeat(1000);
      expect(() => {{FUNCTION_NAME}}(longName, {{AGE_PARAM}})).not.toThrow();
    });

    it('should handle special characters in food names', () => {
      const specialNames = ['Crème brûlée', 'Jalapeño peppers', 'Açaí bowl'];
      
      specialNames.forEach(name => {
        expect(() => {{FUNCTION_NAME}}(name, {{AGE_PARAM}})).not.toThrow();
      });
    });
  });
});`
};

/**
 * E2E Test Template for Authentication Flow
 */
export const authE2ETestTemplate: TestTemplate = {
  name: 'auth-e2e-test',
  type: 'e2e',
  description: 'Template for E2E authentication tests',
  dependencies: ['@playwright/test'],
  template: `/**
 * Authentication E2E Tests
 * Generated by Testing Automation Agent
 */

import { test, expect, Page } from '@playwright/test';
import { AuthPage } from '../pages/AuthPage';

test.describe('Authentication Flow', () => {
  let authPage: AuthPage;

  test.beforeEach(async ({ page }) => {
    authPage = new AuthPage(page);
    await authPage.goto();
  });

  test.describe('Sign Up Flow', () => {
    test('should display sign up form with all required fields', async ({ page }) => {
      await authPage.goToSignUp();
      
      await expect(page.locator('[data-testid="signup-form"]')).toBeVisible();
      await expect(page.locator('[data-testid="email-input"]')).toBeVisible();
      await expect(page.locator('[data-testid="password-input"]')).toBeVisible();
      await expect(page.locator('[data-testid="confirm-password-input"]')).toBeVisible();
      await expect(page.locator('[data-testid="age-select"]')).toBeVisible();
      await expect(page.locator('[data-testid="signup-submit"]')).toBeVisible();
    });

    test('should validate email format', async ({ page }) => {
      await authPage.goToSignUp();
      
      await page.fill('[data-testid="email-input"]', 'invalid-email');
      await page.click('[data-testid="signup-submit"]');
      
      await expect(page.locator('[data-testid="email-error"]')).toContainText('Please enter a valid email');
    });

    test('should validate password strength', async ({ page }) => {
      await authPage.goToSignUp();
      
      await page.fill('[data-testid="password-input"]', '123');
      await page.click('[data-testid="signup-submit"]');
      
      await expect(page.locator('[data-testid="password-error"]')).toContainText('Password must be at least 8 characters');
    });

    test('should successfully create account and redirect to dashboard', async ({ page }) => {
      await authPage.goToSignUp();
      
      const testEmail = \`test-\${Date.now()}@fcinter.com\`;
      await page.fill('[data-testid="email-input"]', testEmail);
      await page.fill('[data-testid="password-input"]', 'SecurePass123!');
      await page.fill('[data-testid="confirm-password-input"]', 'SecurePass123!');
      await page.selectOption('[data-testid="age-select"]', '12');
      
      await page.click('[data-testid="signup-submit"]');
      
      await expect(page).toHaveURL(/.*dashboard/);
      await expect(page.locator('[data-testid="welcome-message"]')).toBeVisible();
    });

    test('should prevent duplicate email registration', async ({ page }) => {
      await authPage.goToSignUp();
      
      // Try to register with existing email
      await page.fill('[data-testid="email-input"]', 'existing@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'SecurePass123!');
      await page.fill('[data-testid="confirm-password-input"]', 'SecurePass123!');
      await page.selectOption('[data-testid="age-select"]', '12');
      
      await page.click('[data-testid="signup-submit"]');
      
      await expect(page.locator('[data-testid="signup-error"]')).toContainText('Email already exists');
    });
  });

  test.describe('Sign In Flow', () => {
    test('should display sign in form with all required fields', async ({ page }) => {
      await expect(page.locator('[data-testid="signin-form"]')).toBeVisible();
      await expect(page.locator('[data-testid="email-input"]')).toBeVisible();
      await expect(page.locator('[data-testid="password-input"]')).toBeVisible();
      await expect(page.locator('[data-testid="remember-me-checkbox"]')).toBeVisible();
      await expect(page.locator('[data-testid="signin-submit"]')).toBeVisible();
    });

    test('should sign in with valid credentials', async ({ page }) => {
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      
      await page.click('[data-testid="signin-submit"]');
      
      await expect(page).toHaveURL(/.*dashboard/);
      await expect(page.locator('[data-testid="user-menu"]')).toBeVisible();
    });

    test('should show error for invalid credentials', async ({ page }) => {
      await page.fill('[data-testid="email-input"]', 'wrong@email.com');
      await page.fill('[data-testid="password-input"]', 'wrongpassword');
      
      await page.click('[data-testid="signin-submit"]');
      
      await expect(page.locator('[data-testid="signin-error"]')).toContainText('Invalid credentials');
    });

    test('should handle Remember me functionality', async ({ page, context }) => {
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      await page.check('[data-testid="remember-me-checkbox"]');
      
      await page.click('[data-testid="signin-submit"]');
      await expect(page).toHaveURL(/.*dashboard/);
      
      // Check if session is persisted
      const cookies = await context.cookies();
      const sessionCookie = cookies.find(cookie => cookie.name.includes('session'));
      expect(sessionCookie).toBeTruthy();
    });
  });

  test.describe('Protected Routes', () => {
    test('should redirect unauthenticated users to sign in', async ({ page }) => {
      await page.goto('/dashboard');
      
      await expect(page).toHaveURL(/.*signin/);
      await expect(page.locator('[data-testid="signin-form"]')).toBeVisible();
    });

    test('should allow authenticated users to access protected routes', async ({ page }) => {
      // Sign in first
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      await page.click('[data-testid="signin-submit"]');
      
      // Navigate to protected route
      await page.goto('/food-log');
      
      await expect(page).toHaveURL(/.*food-log/);
      await expect(page.locator('[data-testid="food-log-container"]')).toBeVisible();
    });
  });

  test.describe('Sign Out Flow', () => {
    test.beforeEach(async ({ page }) => {
      // Sign in before each test
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      await page.click('[data-testid="signin-submit"]');
      await expect(page).toHaveURL(/.*dashboard/);
    });

    test('should sign out and redirect to landing page', async ({ page }) => {
      await page.click('[data-testid="user-menu"]');
      await page.click('[data-testid="signout-button"]');
      
      await expect(page).toHaveURL(/.*signin/);
      await expect(page.locator('[data-testid="signin-form"]')).toBeVisible();
    });
  });

  test.describe('Age-Specific Features', () => {
    test('should show age-appropriate features for U8 players', async ({ page }) => {
      // Sign up as U8 player
      await authPage.signUpAsAgeGroup(7);
      
      await expect(page.locator('[data-testid="simple-interface"]')).toBeVisible();
      await expect(page.locator('[data-testid="parent-supervision-notice"]')).toBeVisible();
    });

    test('should show advanced features for U15 players', async ({ page }) => {
      // Sign up as U15 player
      await authPage.signUpAsAgeGroup(14);
      
      await expect(page.locator('[data-testid="advanced-analytics"]')).toBeVisible();
      await expect(page.locator('[data-testid="performance-correlation"]')).toBeVisible();
    });
  });

  test.describe('Form Validation', () => {
    test('should handle network errors gracefully', async ({ page }) => {
      // Simulate network failure
      await page.route('**/api/auth/**', route => route.abort());
      
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      await page.click('[data-testid="signin-submit"]');
      
      await expect(page.locator('[data-testid="network-error"]')).toBeVisible();
    });

    test('should show loading state during authentication', async ({ page }) => {
      await page.fill('[data-testid="email-input"]', 'test@fcinter.com');
      await page.fill('[data-testid="password-input"]', 'testpass123');
      
      await page.click('[data-testid="signin-submit"]');
      
      await expect(page.locator('[data-testid="loading-spinner"]')).toBeVisible();
    });
  });
});`
};

/**
 * API Integration Test Template
 */
export const apiIntegrationTestTemplate: TestTemplate = {
  name: 'api-integration-test',
  type: 'integration',
  description: 'Template for API integration tests',
  dependencies: ['supertest', 'jest'],
  template: `/**
 * {{API_NAME}} Integration Tests
 * Generated by Testing Automation Agent
 */

import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import app from '{{APP_PATH}}';
import { setupTestDb, cleanupTestDb, createTestUser, getAuthToken } from '../setup';

describe('{{API_NAME}} API Integration Tests', () => {
  let authToken: string;
  let testUserId: string;

  beforeAll(async () => {
    await setupTestDb();
    const testUser = await createTestUser({
      email: 'test@fcinter.com',
      age: 12,
      role: 'PLAYER'
    });
    testUserId = testUser.id;
    authToken = await getAuthToken(testUser);
  });

  afterAll(async () => {
    await cleanupTestDb();
  });

  beforeEach(async () => {
    // Reset any test data before each test
  });

  afterEach(async () => {
    // Clean up after each test
  });

  describe('Authentication', () => {
    it('should reject requests without authentication', async () => {
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .expect(401);

      expect(response.body.error).toContain('Authentication required');
    });

    it('should reject requests with invalid token', async () => {
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401);

      expect(response.body.error).toContain('Invalid token');
    });

    it('should accept requests with valid authentication', async () => {
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        {{REQUEST_BODY}}
        .expect({{SUCCESS_STATUS}});

      expect(response.body).toBeDefined();
    });
  });

  describe('{{API_OPERATION}} Operations', () => {
    it('should handle valid {{API_OPERATION}} requests', async () => {
      const testData = {{TEST_DATA}};

      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(testData)
        .expect({{SUCCESS_STATUS}});

      expect(response.body).toMatchObject({
        {{EXPECTED_RESPONSE_STRUCTURE}}
      });
    });

    it('should validate required fields', async () => {
      const invalidData = {
        // Missing required fields
      };

      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(invalidData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
      expect(response.body.errors).toContain('{{REQUIRED_FIELD}} is required');
    });

    it('should handle data type validation', async () => {
      const invalidData = {
        {{INVALID_DATA_TYPES}}
      };

      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(invalidData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
    });

    it('should enforce business rules', async () => {
      const businessRuleViolationData = {
        {{BUSINESS_RULE_VIOLATION_DATA}}
      };

      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send(businessRuleViolationData)
        .expect(400);

      expect(response.body.error).toContain('{{BUSINESS_RULE_ERROR}}');
    });
  });

  describe('Age-Specific Logic', () => {
    it('should apply U8 player restrictions', async () => {
      const u8Token = await getAuthToken(await createTestUser({ age: 7 }));
      
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${u8Token}\`)
        .send({{TEST_DATA}})
        .expect({{SUCCESS_STATUS}});

      expect(response.body.ageRestrictions).toBe(true);
      expect(response.body.parentalSupervision).toBe(true);
    });

    it('should enable advanced features for U15 players', async () => {
      const u15Token = await getAuthToken(await createTestUser({ age: 14 }));
      
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${u15Token}\`)
        .send({{TEST_DATA}})
        .expect({{SUCCESS_STATUS}});

      expect(response.body.advancedFeatures).toBe(true);
      expect(response.body.performanceTracking).toBe(true);
    });

    it('should apply age-specific nutrition multipliers', async () => {
      const ages = [7, 9, 11, 14];
      
      for (const age of ages) {
        const ageToken = await getAuthToken(await createTestUser({ age }));
        
        const response = await request(app)
          .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
          .set('Authorization', \`Bearer \${ageToken}\`)
          .send({ foodName: 'Grilled chicken with rice' })
          .expect({{SUCCESS_STATUS}});

        expect(response.body.ageMultipliers).toBeDefined();
        expect(response.body.adjustedScore).toBeDefined();
      }
    });
  });

  describe('Food Analysis Integration', () => {
    it('should analyze food quality correctly', async () => {
      const testFoods = [
        { name: 'Quinoa salad with salmon', expectedQuality: 'excellent' },
        { name: 'Grilled chicken with rice', expectedQuality: 'good' },
        { name: 'White bread sandwich', expectedQuality: 'fair' },
        { name: 'Candy bar', expectedQuality: 'poor' }
      ];

      for (const food of testFoods) {
        const response = await request(app)
          .post('/api/food/analyze')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({ foodName: food.name })
          .expect(200);

        expect(response.body.quality).toBe(food.expectedQuality);
      }
    });

    it('should provide age-appropriate recommendations', async () => {
      const response = await request(app)
        .post('/api/food/analyze')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({ foodName: 'Sports drink' })
        .expect(200);

      expect(response.body.recommendations).toBeDefined();
      expect(response.body.ageSpecificAdvice).toBeDefined();
    });

    it('should handle meal timing analysis', async () => {
      const timings = ['PRE_TRAINING', 'POST_TRAINING', 'MATCH_DAY'];
      
      for (const timing of timings) {
        const response = await request(app)
          .post('/api/food/analyze')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({
            foodName: 'Banana with oats',
            mealTiming: timing
          })
          .expect(200);

        expect(response.body.timingScore).toBeDefined();
        expect(response.body.timingRecommendations).toBeDefined();
      }
    });
  });

  describe('Performance Metrics', () => {
    it('should track nutrition performance correlation', async () => {
      // Create multiple food entries
      const foodEntries = [
        { foodName: 'Excellent meal', quality: 'excellent' },
        { foodName: 'Good meal', quality: 'good' },
        { foodName: 'Poor meal', quality: 'poor' }
      ];

      for (const entry of foodEntries) {
        await request(app)
          .post('/api/food/entries')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send(entry)
          .expect(201);
      }

      // Get performance analytics
      const response = await request(app)
        .get('/api/analytics/nutrition-performance')
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      expect(response.body.correlationData).toBeDefined();
      expect(response.body.performanceInsights).toBeDefined();
    });

    it('should provide trend analysis', async () => {
      const response = await request(app)
        .get('/api/analytics/trends')
        .set('Authorization', \`Bearer \${authToken}\`)
        .query({ period: '7days' })
        .expect(200);

      expect(response.body.nutritionTrends).toBeDefined();
      expect(response.body.improvementAreas).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should handle database connection errors', async () => {
      // Simulate database error
      // This would require mocking or temporarily disconnecting the database
      
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send({{TEST_DATA}})
        .expect(500);

      expect(response.body.error).toContain('Internal server error');
    });

    it('should handle malformed request data', async () => {
      const response = await request(app)
        .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
        .set('Authorization', \`Bearer \${authToken}\`)
        .send('invalid json')
        .expect(400);

      expect(response.body.error).toContain('Invalid request format');
    });

    it('should handle rate limiting', async () => {
      // Make multiple rapid requests
      const requests = Array(100).fill().map(() =>
        request(app)
          .{{HTTP_METHOD}}('{{API_ENDPOINT}}')
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({{TEST_DATA}})
      );

      const responses = await Promise.allSettled(requests);
      const rateLimitedResponses = responses.filter(
        result => result.status === 'fulfilled' && result.value.status === 429
      );

      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  describe('Data Integrity', () => {
    it('should maintain referential integrity', async () => {
      // Test cascading deletes, foreign key constraints, etc.
      const response = await request(app)
        .delete(\`/api/users/\${testUserId}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(200);

      // Verify related data is cleaned up
      const relatedDataResponse = await request(app)
        .get(\`/api/food/entries/user/\${testUserId}\`)
        .set('Authorization', \`Bearer \${authToken}\`)
        .expect(404);
    });

    it('should handle concurrent modifications', async () => {
      // Test optimistic locking or other concurrency controls
      const concurrentRequests = [
        request(app)
          .put(\`/api/{{RESOURCE}}/\${testUserId}\`)
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({{UPDATE_DATA_1}}),
        request(app)
          .put(\`/api/{{RESOURCE}}/\${testUserId}\`)
          .set('Authorization', \`Bearer \${authToken}\`)
          .send({{UPDATE_DATA_2}})
      ];

      const results = await Promise.allSettled(concurrentRequests);
      // One should succeed, one should fail with conflict
      const successCount = results.filter(r => r.status === 'fulfilled' && r.value.status < 400).length;
      expect(successCount).toBe(1);
    });
  });
});`
};

/**
 * Hook Test Template
 */
export const hookTestTemplate: TestTemplate = {
  name: 'hook-test',
  type: 'unit',
  description: 'Template for React hook tests',
  dependencies: ['@testing-library/react-hooks', 'vitest'],
  template: `/**
 * {{HOOK_NAME}} Hook Tests
 * Generated by Testing Automation Agent
 */

import { renderHook, act } from '@testing-library/react-hooks';
import { vi } from 'vitest';
import { {{HOOK_NAME}} } from '{{HOOK_PATH}}';
{{ADDITIONAL_IMPORTS}}

// Mock dependencies
{{MOCKS}}

describe('{{HOOK_NAME}}', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    {{BEFORE_EACH_SETUP}}
  });

  afterEach(() => {
    {{AFTER_EACH_CLEANUP}}
  });

  describe('Initial State', () => {
    it('should return initial state correctly', () => {
      const { result } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      expect(result.current).toMatchObject({
        {{EXPECTED_INITIAL_STATE}}
      });
    });

    it('should handle custom initial parameters', () => {
      const customParams = {{CUSTOM_PARAMS}};
      const { result } = renderHook(() => {{HOOK_NAME}}(customParams));
      
      expect(result.current.{{STATE_PROPERTY}}).toBe({{EXPECTED_VALUE}});
    });
  });

  describe('State Updates', () => {
    it('should update state correctly', async () => {
      const { result } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      act(() => {
        result.current.{{UPDATE_FUNCTION}}({{UPDATE_VALUE}});
      });
      
      expect(result.current.{{STATE_PROPERTY}}).toBe({{EXPECTED_UPDATED_VALUE}});
    });

    it('should handle async state updates', async () => {
      const { result, waitForNextUpdate } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      act(() => {
        result.current.{{ASYNC_FUNCTION}}({{ASYNC_PARAMS}});
      });
      
      expect(result.current.loading).toBe(true);
      
      await waitForNextUpdate();
      
      expect(result.current.loading).toBe(false);
      expect(result.current.{{RESULT_PROPERTY}}).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should handle errors gracefully', async () => {
      const { result, waitForNextUpdate } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      // Mock an error
      {{ERROR_MOCK_SETUP}}
      
      act(() => {
        result.current.{{ERROR_TRIGGERING_FUNCTION}}();
      });
      
      await waitForNextUpdate();
      
      expect(result.current.error).toBeDefined();
      expect(result.current.loading).toBe(false);
    });

    it('should reset error state on retry', async () => {
      const { result, waitForNextUpdate } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      // Trigger error first
      {{ERROR_TRIGGER}}
      await waitForNextUpdate();
      expect(result.current.error).toBeDefined();
      
      // Reset and retry
      act(() => {
        result.current.retry();
      });
      
      expect(result.current.error).toBe(null);
      expect(result.current.loading).toBe(true);
    });
  });

  describe('Cleanup', () => {
    it('should cleanup on unmount', () => {
      const { unmount } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      unmount();
      
      // Verify cleanup
      {{CLEANUP_VERIFICATION}}
    });

    it('should cancel pending requests on unmount', () => {
      const { result, unmount } = renderHook(() => {{HOOK_NAME}}({{DEFAULT_PARAMS}}));
      
      act(() => {
        result.current.{{ASYNC_FUNCTION}}({{ASYNC_PARAMS}});
      });
      
      unmount();
      
      // Verify request was cancelled
      {{CANCELLATION_VERIFICATION}}
    });
  });

  {{ADDITIONAL_TESTS}}
});`
};

/**
 * Performance Test Template
 */
export const performanceTestTemplate: TestTemplate = {
  name: 'performance-test',
  type: 'e2e',
  description: 'Template for performance and load tests',
  dependencies: ['@playwright/test'],
  template: `/**
 * Performance Tests for {{COMPONENT_NAME}}
 * Generated by Testing Automation Agent
 */

import { test, expect, Page } from '@playwright/test';

test.describe('{{COMPONENT_NAME}} Performance Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Enable performance monitoring
    await page.goto('{{BASE_URL}}', { waitUntil: 'networkidle' });
  });

  test('should load within acceptable time limits', async ({ page }) => {
    const startTime = Date.now();
    
    await page.goto('{{TEST_URL}}');
    await page.waitForSelector('[data-testid="{{MAIN_COMPONENT}}"]');
    
    const loadTime = Date.now() - startTime;
    
    expect(loadTime).toBeLessThan(3000); // 3 seconds max
  });

  test('should handle large food databases efficiently', async ({ page }) => {
    await page.goto('{{FOOD_LOG_URL}}');
    
    // Measure time to load and search through food database
    const startTime = performance.now();
    
    await page.fill('[data-testid="food-search"]', 'chicken');
    await page.waitForSelector('[data-testid="search-results"]');
    
    const searchTime = performance.now() - startTime;
    
    expect(searchTime).toBeLessThan(500); // 500ms max for search
  });

  test('should maintain performance with multiple food entries', async ({ page }) => {
    await page.goto('{{FOOD_LOG_URL}}');
    
    // Add multiple entries and measure performance
    const entries = Array.from({ length: 20 }, (_, i) => ({
      food: \`Test Food \${i}\`,
      mealType: 'LUNCH'
    }));
    
    const startTime = performance.now();
    
    for (const entry of entries) {
      await page.fill('[data-testid="food-name"]', entry.food);
      await page.selectOption('[data-testid="meal-type"]', entry.mealType);
      await page.click('[data-testid="add-entry"]');
      await page.waitForSelector(\`[data-testid="entry-\${entry.food}"]`);
    }
    
    const totalTime = performance.now() - startTime;
    const averageTimePerEntry = totalTime / entries.length;
    
    expect(averageTimePerEntry).toBeLessThan(200); // 200ms per entry max
  });

  test('should analyze nutrition calculations efficiently', async ({ page }) => {
    await page.goto('{{ANALYTICS_URL}}');
    
    // Measure analytics calculation time
    const startTime = performance.now();
    
    await page.click('[data-testid="calculate-analytics"]');
    await page.waitForSelector('[data-testid="analytics-results"]');
    
    const calculationTime = performance.now() - startTime;
    
    expect(calculationTime).toBeLessThan(1000); // 1 second max
  });

  test('should handle concurrent users efficiently', async ({ browser }) => {
    const contexts = await Promise.all([
      browser.newContext(),
      browser.newContext(),
      browser.newContext(),
      browser.newContext(),
      browser.newContext()
    ]);
    
    const pages = await Promise.all(
      contexts.map(context => context.newPage())
    );
    
    const startTime = performance.now();
    
    // Simulate concurrent usage
    await Promise.all(pages.map(async (page, index) => {
      await page.goto('{{TEST_URL}}');
      await page.fill('[data-testid="food-name"]', \`Concurrent Food \${index}\`);
      await page.click('[data-testid="add-entry"]');
      await page.waitForSelector(\`[data-testid="entry-Concurrent Food \${index}"]`);
    }));
    
    const concurrentTime = performance.now() - startTime;
    
    expect(concurrentTime).toBeLessThan(5000); // 5 seconds max for 5 concurrent users
    
    // Cleanup
    await Promise.all(contexts.map(context => context.close()));
  });

  test('should maintain performance on mobile devices', async ({ browser }) => {
    const mobileContext = await browser.newContext({
      ...devices['iPhone 12'],
      // Simulate slower mobile network
      offline: false,
      // Throttle network
    });
    
    const page = await mobileContext.newPage();
    
    const startTime = performance.now();
    
    await page.goto('{{TEST_URL}}');
    await page.waitForSelector('[data-testid="{{MAIN_COMPONENT}}"]');
    
    const mobileLoadTime = performance.now() - startTime;
    
    expect(mobileLoadTime).toBeLessThan(5000); // 5 seconds max on mobile
    
    await mobileContext.close();
  });

  test('should handle memory usage efficiently', async ({ page }) => {
    await page.goto('{{TEST_URL}}');
    
    // Measure initial memory
    const initialMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        return (performance as any).memory.usedJSHeapSize;
      }
      return 0;
    });
    
    // Perform memory-intensive operations
    for (let i = 0; i < 100; i++) {
      await page.fill('[data-testid="food-name"]', \`Memory Test Food \${i}\`);
      await page.click('[data-testid="add-entry"]');
      await page.waitForSelector(\`[data-testid="entry-Memory Test Food \${i}"]`);
      
      // Clear entry to test cleanup
      await page.click(\`[data-testid="delete-entry-Memory Test Food \${i}"]`);
    }
    
    // Force garbage collection if available
    await page.evaluate(() => {
      if ('gc' in window) {
        (window as any).gc();
      }
    });
    
    const finalMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        return (performance as any).memory.usedJSHeapSize;
      }
      return 0;
    });
    
    if (initialMemory > 0 && finalMemory > 0) {
      const memoryIncrease = finalMemory - initialMemory;
      const maxMemoryIncrease = 10 * 1024 * 1024; // 10MB max increase
      
      expect(memoryIncrease).toBeLessThan(maxMemoryIncrease);
    }
  });

  test('should handle offline scenarios gracefully', async ({ page, context }) => {
    await page.goto('{{TEST_URL}}');
    
    // Go offline
    await context.setOffline(true);
    
    // Try to perform operations
    await page.fill('[data-testid="food-name"]', 'Offline Test Food');
    await page.click('[data-testid="add-entry"]');
    
    // Should show offline message
    await expect(page.locator('[data-testid="offline-notification"]')).toBeVisible();
    
    // Go back online
    await context.setOffline(false);
    
    // Should sync data
    await page.waitForSelector('[data-testid="sync-notification"]');
    await expect(page.locator('[data-testid="entry-Offline Test Food"]')).toBeVisible();
  });
});`
};

/**
 * Visual Regression Test Template
 */
export const visualTestTemplate: TestTemplate = {
  name: 'visual-test',
  type: 'e2e',
  description: 'Template for visual regression tests',
  dependencies: ['@playwright/test'],
  template: `/**
 * Visual Regression Tests for {{COMPONENT_NAME}}
 * Generated by Testing Automation Agent
 */

import { test, expect } from '@playwright/test';

test.describe('{{COMPONENT_NAME}} Visual Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('{{TEST_URL}}');
    // Wait for fonts and assets to load
    await page.waitForLoadState('networkidle');
  });

  test('should match desktop layout screenshot', async ({ page }) => {
    await page.setViewportSize({ width: 1200, height: 800 });
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-desktop.png');
  });

  test('should match tablet layout screenshot', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 });
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-tablet.png');
  });

  test('should match mobile layout screenshot', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-mobile.png');
  });

  test('should handle different age group interfaces', async ({ page }) => {
    // Test U8 interface
    await page.goto('{{TEST_URL}}?age=8');
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-u8.png');
    
    // Test U15 interface
    await page.goto('{{TEST_URL}}?age=15');
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-u15.png');
  });

  test('should handle different nutrition score states', async ({ page }) => {
    // Test excellent score display
    await page.route('**/api/food/analyze', route => {
      route.fulfill({
        status: 200,
        body: JSON.stringify({ score: 95, quality: 'excellent' })
      });
    });
    
    await page.fill('[data-testid="food-name"]', 'Test Food');
    await page.click('[data-testid="analyze-button"]');
    await page.waitForSelector('[data-testid="nutrition-score"]');
    
    await expect(page.locator('[data-testid="nutrition-display"]')).toHaveScreenshot('nutrition-excellent.png');
    
    // Test poor score display
    await page.route('**/api/food/analyze', route => {
      route.fulfill({
        status: 200,
        body: JSON.stringify({ score: 25, quality: 'poor' })
      });
    });
    
    await page.fill('[data-testid="food-name"]', 'Poor Food');
    await page.click('[data-testid="analyze-button"]');
    await page.waitForSelector('[data-testid="nutrition-score"]');
    
    await expect(page.locator('[data-testid="nutrition-display"]')).toHaveScreenshot('nutrition-poor.png');
  });

  test('should handle loading and error states', async ({ page }) => {
    // Test loading state
    await page.route('**/api/food/analyze', route => {
      // Delay response to capture loading state
      setTimeout(() => {
        route.fulfill({
          status: 200,
          body: JSON.stringify({ score: 80, quality: 'good' })
        });
      }, 2000);
    });
    
    await page.fill('[data-testid="food-name"]', 'Loading Test');
    await page.click('[data-testid="analyze-button"]');
    
    await expect(page.locator('[data-testid="loading-state"]')).toHaveScreenshot('loading-state.png');
    
    // Test error state
    await page.route('**/api/food/analyze', route => {
      route.fulfill({
        status: 500,
        body: JSON.stringify({ error: 'Analysis failed' })
      });
    });
    
    await page.fill('[data-testid="food-name"]', 'Error Test');
    await page.click('[data-testid="analyze-button"]');
    await page.waitForSelector('[data-testid="error-message"]');
    
    await expect(page.locator('[data-testid="error-state"]')).toHaveScreenshot('error-state.png');
  });

  test('should handle dark mode variations', async ({ page }) => {
    // Test light mode
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-light.png');
    
    // Switch to dark mode if supported
    await page.evaluate(() => {
      document.documentElement.classList.add('dark');
    });
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-dark.png');
  });

  test('should handle different data states', async ({ page }) => {
    // Empty state
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-empty.png');
    
    // Populated state
    await page.fill('[data-testid="food-name"]', 'Chicken Breast');
    await page.selectOption('[data-testid="meal-type"]', 'LUNCH');
    await page.click('[data-testid="add-entry"]');
    await page.waitForSelector('[data-testid="food-entry"]');
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-populated.png');
  });

  test('should handle animation states', async ({ page }) => {
    // Disable animations for consistent screenshots
    await page.addStyleTag({
      content: \`
        *, *::before, *::after {
          animation-duration: 0s !important;
          animation-delay: 0s !important;
          transition-duration: 0s !important;
          transition-delay: 0s !important;
        }
      \`
    });
    
    await expect(page.locator('[data-testid="{{COMPONENT}}"]')).toHaveScreenshot('{{COMPONENT}}-no-animations.png');
  });
});`
};

export const testTemplates = {
  component: componentTestTemplate,
  foodAnalysis: foodAnalysisTestTemplate,
  authE2E: authE2ETestTemplate,
  apiIntegration: apiIntegrationTestTemplate,
  hook: hookTestTemplate,
  performance: performanceTestTemplate,
  visual: visualTestTemplate
};

/**
 * Get template by name
 */
export function getTemplate(name: string): TestTemplate | undefined {
  return Object.values(testTemplates).find(template => template.name === name);
}

/**
 * Get templates by type
 */
export function getTemplatesByType(type: TestTemplate['type']): TestTemplate[] {
  return Object.values(testTemplates).filter(template => template.type === type);
}

/**
 * Validate template variables
 */
export function validateTemplateVariables(template: string, variables: Record<string, string>): string[] {
  const errors: string[] = [];
  const requiredVariables = template.match(/\{\{[A-Z_]+\}\}/g) || [];
  
  requiredVariables.forEach(variable => {
    const varName = variable.replace(/[{}]/g, '');
    if (!variables[varName]) {
      errors.push(`Missing required variable: ${varName}`);
    }
  });
  
  return errors;
}

/**
 * Render template with variables
 */
export function renderTemplate(template: string, variables: Record<string, string>): string {
  let rendered = template;
  
  Object.entries(variables).forEach(([key, value]) => {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    rendered = rendered.replace(regex, value);
  });
  
  return rendered;
}